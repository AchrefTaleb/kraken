{"google":"","body":"### Overview\r\n\r\nKraken is a distributed pubsub server that is designed to handle the performance demands of highly collaborative realtime apps like Asana.\r\n\r\n### Building and Running Kraken\r\n\r\nPackaged versions of Kraken are coming soon, but for now you will need to install from source.\r\n\r\nKraken is written in Erlang, so you will need to run Kraken on a machine with Erlang installed. We recommend running it with Erlang R15B02 and above, but it probably works with older versions of Erlang as well.\r\n\r\nDownload the latest Kraken release (or clone the git project), and then use the following command from the root of the Kraken directory to build Kraken for the first time:\r\n\r\n    ./rebar get-deps compile\r\n\r\nYou can now run Kraken in the foreground like this:\r\n\r\n    bin/kraken run\r\n\r\nThis will start Kraken up with the default config. It will listen to new TCP connections on port 12355.\r\n\r\n### Kraken clients\r\n\r\nKraken currently includes two official clients, for Erlang and Node.js. However, the default Kraken protocol is based on the memcached protocol, so it shouldn't take very long to create a client in the language of your choice. If you do, please contribute it back to Kraken!\r\n\r\nHere is an example of working with Kraken using the Node.js client:\r\n\r\n    js> kraken1 = new Kraken(\"localhost\", 12355);\r\n    js> kranen2 = new Kraken(\"localhost\", 12355);\r\n    js> kraken1.subscribe([\"topicA\", \"topicB\"]);\r\n    js> kraken2.publish([\"topicA\"], \"hi there!\");\r\n    js> console.log(kraken1.receiveMessages());\r\n    js> kraken2.unsubscribe([\"topicA\"]);\r\n\r\n### How do you use Kraken to build Realtime web apps\r\n\r\nKraken was designed to forward data invalidation messages between application servers. It's up to the application designer to figure out how to scope these messages to topics, and what they should contain. For example, a simple TODO list app may have topics corresponding to each of the lists that a user can see. This app would publish invalidation messages corresponding to the ids of tasks that have changed through the topics corresponding to the lists that the task is and was a member of. When other application servers receive these messages, they would reload the state of the tasks referenced in the invalidations messages to ensure they are still up to date.\r\n\r\n### How does Kraken scale?\r\n\r\nAs far as we know, very well. Kraken has been powering the Asana service since mid 2010, and has yet to crash or fail in any way. At Asana, we have 10s of thousands of clients connected to each Kraken node.\r\n\r\nThere are two ways of scaling Kraken beyond a single machine:\r\n\r\n1. You can shard the topic space so that each machine is responsible for a portion of the topics. This will typically decrease the total number of messages that a given node needs to process and reduce the amount of memory required to keep track of all the routing information.\r\n\r\n2. You can run Kraken nodes that proxy to other Kraken nodes. The proxy nodes will aggregate connections and routing information from their clients and forward on the minimal amount of information necessary to ensure they stay up to date. The proxy nodes then become a single client to the Kraken nodes that they connect to, substantially decreasing the total number of clients and messages that any single Kraken node needs to handle!\r\n\r\n### Authors and Contributors\r\n\r\nKraken was originally written at Asana by Kris Rasmussen (@krisr).\r\n\r\n### Support or Contact\r\nHaving trouble with Kraken? Check out the documentation at https://github.com/Asana/Kraken/wiki or file an issue at https://github.com/Asana/Kraken/issues and weâ€™ll help you sort it out.","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Pubsub server for realtime apps","name":"Kraken"}