<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Kraken : Pubsub server for realtime apps" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Kraken</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Asana/kraken">View on GitHub</a>

          <h1 id="project_title">Kraken</h1>
          <h2 id="project_tagline">Pubsub server for realtime apps</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Asana/kraken/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Asana/kraken/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>Overview</h3>

<p>Kraken is a distributed pubsub server that is designed to power collaborative realtime apps like <a href="http://www.asana.com">Asana</a>.</p>

<p>Applications use Kraken to transmit and receive messages through topics. These messages will typically contain just enough information
to identify the set of data that was changed by the client just before the message was published. When other clients
receive these messages, they will figure out which data changed and reload it from the datastore so that they are eventually brought up to date.</p>

<p>Kraken is not a general purpose message bus like <a href="http://www.rabbitmq.com/">RabbitMQ</a>.</p>

<h3>Building Kraken for the first time</h3>

<p>We recommend running Kraken with <a href="http://www.erlang.org/download.html">Erlang R15B03</a> and above, but it will likely work fine with older versions of Erlang as well.</p>

<p>Download the latest Kraken release (or clone the git project), and then use the following command from the root of the Kraken directory to build Kraken for the first time:</p>

<pre><code>./rebar get-deps compile
</code></pre>

<p>You can now run Kraken in the foreground like this:</p>

<pre><code>bin/kraken run
</code></pre>

<p>This will start Kraken up with the default config. It will listen to new TCP connections on port 12355.</p>

<h3>Running Kraken</h3>

<p>Kraken comes with a little bash script that provides a handful of useful commands:</p>

<p>Running Kraken in the foreground, with a live erlang shell</p>

<pre><code>bin/kraken run
</code></pre>

<p>Starting and Stopping Kraken in the background</p>

<pre><code>bin/kraken start
bin/kraken stop
</code></pre>

<p>Checking if Kraken is currently running in the background</p>

<pre><code>bin/kraken status
</code></pre>

<p>Changing the Kraken log level while it is running</p>

<pre><code>bin/kraken change_log_level [debug|info|warn|error]
</code></pre>

<p>Dumping information about every client queue</p>

<pre><code>bin/kraken dump_queues
</code></pre>

<p>Dumping the list of topics for a particular client's queue</p>

<pre><code>bin/kraken dump_queue_topics &lt;pid from dump_queues&gt;
</code></pre>

<p>Dumping all topics with a count of subscribers</p>

<pre><code>bin/kraken dump_topics
</code></pre>

<h3>Configuring Kraken</h3>

<p>Before running Kraken in production, you will want to customize some of the config options. Kraken is built as a standard OTP application, so you can modify config options directly from the command line or by specifying a custom erlang config.</p>

<h4>Supported options</h4>

<ul>
<li>
<strong>pid_file</strong>: If specified, then the system process id of the erlang node will be written to this file.</li>
<li>
<strong>listen_ip</strong>: The IP address for the Kraken server to listen to new connections on.</li>
<li>
<strong>tcp_server_port</strong>: The port for the Kraken server to listen to new connections on.</li>
<li>
<strong>num_router_shards</strong>: The number of router shards to run. A good starting point is 2x the number of cores on the machine.</li>
<li>
<strong>router_min_fanout_to_warn</strong>: Octopus will log warnings if a message ends up being distributed to this many or more subscribers.</li>
</ul><p><strong>Specifying options at the command line</strong></p>

<p>You can specify Kraken options at the command line when starting Kraken as follows:</p>

<pre><code>bin/kraken run -kraken num_router_shards 8 -kraken router_min_fanout_to_warn 1000
</code></pre>

<p>You need to prefix each argument with "-kraken" to let erlang know that you are customizing the kraken application environment. Erlang lets you run multiple applications on a single node.</p>

<p><strong>Specifying options in a config file</strong></p>

<p>Kraken options can also be specified in an erlang config file. Here is an example config file:</p>

<pre><code>[{octopus, [
   {pid_file, "/var/run/kraken.pid"},
   {log_file, "/var/log/kraken.log"},
   {max_tcp_clients, 30000},
   {num_router_shards, 8}]}].
</code></pre>

<p>If you stored the config file in /etc/kraken.config, you could tell Erlang to use the config when you start it as follows:</p>

<pre><code>bin/kraken start -config /etc/kraken
</code></pre>

<p>Note that Erlang requires you to exclude the extension when you specify the config file.</p>

<h3>Kraken clients</h3>

<p>Kraken currently includes two official clients for Erlang and Node.js. The <a href="https://github.com/Asana/Kraken/blob/master/src/kraken_memcached.erl">Kraken protocol</a> is based on the Memcached protocol, so it shouldn't take very long to create a client in the language of your choice. Please let us know if you create a new client!</p>

<p>Here is an example of working with Kraken using the <a href="https://github.com/Asana/kraken-node-client">Node.js client</a>:</p>

<pre><code>js&gt; kraken1 = new Kraken("localhost", 12355);
js&gt; kranen2 = new Kraken("localhost", 12355);
js&gt; kraken1.subscribe(["topicA", "topicB"]);
js&gt; kraken2.publish(["topicA"], "hi there!");
js&gt; console.log(kraken1.receiveMessages());
js&gt; kraken2.unsubscribe(["topicA"]);
</code></pre>

<p>As you see above, the Memcached based protocol requires clients to poll for new messages. Most good message bus proctocols (like AMQP) have some kind of polling in the form of a heart beat so that clients can detect dead connections sooner than later. In Kraken, the receive command is the way to receive new messages and the heartbeat at the same time. A decent machine should be able to handle thousands of clients polling once every couple of seconds without a problem. It probably wouldn't take very long to add a new protocol to Kraken that pushes messages to clients if you need it! Kraken was designed with the goal of supporting multiple protocols in the future.</p>

<h3>How do I use Kraken to build realtime apps?</h3>

<p>Kraken was designed to forward data invalidation messages between application servers. It's up to the application designer to figure out how to scope these messages to topics, and what they should contain. For example, a simple TODO list app may have topics corresponding to each of the lists that a user can see. This app would publish invalidation messages corresponding to the ids of tasks that have changed through the topics corresponding to the lists that the task is and was a member of. When other application servers receive these messages, they would reload the state of the tasks referenced in the invalidations messages to ensure they are still up to date.</p>

<h3>How does Kraken scale?</h3>

<p>As far as we know, very well. Kraken has been powering the Asana service since mid 2010, and has yet to crash or fail in any way. At Asana, we have 10s of thousands of clients connected to each Kraken node.</p>

<p>There are two ways of scaling Kraken beyond a single machine:</p>

<ol>
<li><p>You can shard the topic space so that each machine is responsible for a portion of the topics. This will typically decrease the total number of messages that a given node needs to process and reduce the amount of memory required to keep track of all the routing information.</p></li>
<li><p>You can run Kraken nodes that proxy to other Kraken nodes. The proxy nodes will aggregate connections and routing information from their clients and forward on the minimal amount of information necessary to ensure they stay up to date. The proxy nodes then become a single client to the Kraken nodes that they connect to, substantially decreasing the total number of clients and messages that any single Kraken node needs to handle!</p></li>
</ol><h3>Authors and Contributors</h3>

<p>Kraken was originally written by Kris Rasmussen (<a href="https://github.com/krisr" class="user-mention">@krisr</a>) at <a href="http://www.asana.com/jobs">Asana</a>. The Kraken mascot was designed by Stephanie Hornung.</p>

<h3>Support or Contact</h3>

<p>Having trouble with Kraken? Check out the documentation at <a href="https://github.com/Asana/Kraken/wiki">https://github.com/Asana/Kraken/wiki</a> or file an issue at <a href="https://github.com/Asana/Kraken/issues">https://github.com/Asana/Kraken/issues</a> and weâ€™ll help you sort it out.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Kraken maintained by <a href="https://github.com/Asana">Asana</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
